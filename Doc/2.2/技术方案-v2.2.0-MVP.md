# v2.2.0 MVP - æŠ€æœ¯æ–¹æ¡ˆ

> **ç‰ˆæœ¬**ï¼šv2.2.0  
> **æ—¥æœŸ**ï¼š2026-01-20  
> **çŠ¶æ€**ï¼šå¾…å®¡æ ¸  
> **å…³è” PRD**ï¼š[v2.2.0 MVP PRD](./2.2.0-MVP.md)  
> **æ ¸å¿ƒæ¶æ„**ï¼š[æŠ€æœ¯æ–¹æ¡ˆ-æ ¸å¿ƒæ¶æ„](./æŠ€æœ¯æ–¹æ¡ˆ-æ ¸å¿ƒæ¶æ„.md)

---

## ä¸€ã€ç‰ˆæœ¬èŒƒå›´

### 1.1 äº¤ä»˜åŠŸèƒ½

- âœ… å…³é”®è¯è§¦å‘æ£€æµ‹ï¼ˆä¸å½±å“é—²èŠï¼‰
- âœ… å¤æ‚åº¦åˆ†çº§æ¡†æ¶
- âœ… ä½å¤æ‚åº¦ä»»åŠ¡æ‰§è¡Œï¼ˆå¤©æ°”æŸ¥è¯¢ï¼‰
- âœ… åŸºç¡€é…ç½®æ¨¡æ¿è§£æ
- âœ… å¤©æ°”ç»“æœå¡ç‰‡
- âœ… 2s å“åº”ä¿éšœ

### 1.2 ä¸åŒ…å«

- âŒ ç”¨æˆ·åå¥½è®°å¿†ï¼ˆv2.2.1ï¼‰
- âŒ å¼‚æ­¥æ‰§è¡Œï¼ˆv2.2.1ï¼‰
- âŒ ç¡®è®¤æµç¨‹ï¼ˆv2.2.2ï¼‰
- âŒ å¤šä»»åŠ¡ï¼ˆv2.2.3ï¼‰

---

## äºŒã€æŠ€æœ¯æ¶æ„

### 2.1 æ¨¡å—å…³ç³»

```
ç”¨æˆ·è¾“å…¥
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ActionDetector (ç°æœ‰)                                        â”‚
â”‚ æ£€æµ‹ [ACTION:TASK:xxx] æ ‡ç­¾                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ /api/task/dispatch                                           â”‚
â”‚ ä»»åŠ¡è°ƒåº¦å…¥å£                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TaskMatcher                                                  â”‚
â”‚ åŠ è½½é…ç½® â†’ å…³é”®è¯åŒ¹é… â†’ è¿”å›åŒ¹é…ç»“æœ                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TaskDispatcher                                               â”‚
â”‚ åˆ›å»ºä¼šè¯ â†’ åˆ¤æ–­å¤æ‚åº¦ â†’ åˆ†å‘æ‰§è¡Œ                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ WeatherExecutor                                              â”‚
â”‚ è°ƒç”¨ç™¾ç‚¼ API â†’ è§£æç»“æœ                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PersonaBroadcaster                                           â”‚
â”‚ æ ¼å¼åŒ–ç»“æœ â†’ äººè®¾åŒ–æ’­æŠ¥                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SendAgentInstanceLLM                                         â”‚
â”‚ æ³¨å…¥ç»“æœåˆ°äººè®¾ LLM                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ•°æ®æµæ—¶åº

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant ASR as ASR
    participant LLM as äººè®¾ LLM
    participant FE as å‰ç«¯
    participant API as /api/task/dispatch
    participant Exec as WeatherExecutor
    participant Bailian as ç™¾ç‚¼ API

    User->>ASR: "ä»Šå¤©å¤©æ°”æ€ä¹ˆæ ·"
    ASR->>LLM: æ–‡æœ¬
    LLM->>FE: "å¥½çš„ [ACTION:TASK:weather]"
    FE->>API: POST {taskType: "weather"}
    
    API->>API: TaskMatcher.match()
    API->>API: TaskDispatcher.dispatch()
    API->>Exec: execute()
    Exec->>Bailian: è”ç½‘æœç´¢
    Bailian-->>Exec: å¤©æ°”æ•°æ®
    Exec-->>API: WeatherResult
    
    API->>LLM: SendAgentInstanceLLM(ç»“æœ)
    LLM->>FE: "åŒ—äº¬ä»Šå¤©æ™´è½¬å¤šäº‘..."
    FE->>FE: æ˜¾ç¤ºå¤©æ°”å¡ç‰‡
    FE->>User: è¯­éŸ³ + å¡ç‰‡
```

---

## ä¸‰ã€æ–‡ä»¶ç»“æ„

### 3.1 æ–°å¢æ–‡ä»¶

```
Source/server/
â”œâ”€â”€ app/api/task/
â”‚   â””â”€â”€ dispatch/
â”‚       â””â”€â”€ route.ts           # [NEW] ä»»åŠ¡è°ƒåº¦ API
â”‚
â”œâ”€â”€ lib/tasks/
â”‚   â”œâ”€â”€ index.ts               # [NEW] æ¨¡å—å¯¼å‡º
â”‚   â”œâ”€â”€ types.ts               # [NEW] ç±»å‹å®šä¹‰
â”‚   â”‚
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ task-matcher.ts    # [NEW] ä»»åŠ¡åŒ¹é…å™¨
â”‚   â”‚   â”œâ”€â”€ task-dispatcher.ts # [NEW] ä»»åŠ¡è°ƒåº¦å™¨
â”‚   â”‚   â”œâ”€â”€ task-session.ts    # [NEW] ä¼šè¯ç®¡ç†
â”‚   â”‚   â””â”€â”€ config-loader.ts   # [NEW] é…ç½®åŠ è½½
â”‚   â”‚
â”‚   â”œâ”€â”€ executors/
â”‚   â”‚   â”œâ”€â”€ base-executor.ts   # [NEW] æ‰§è¡Œå™¨åŸºç±»
â”‚   â”‚   â””â”€â”€ weather-executor.ts# [NEW] å¤©æ°”æ‰§è¡Œå™¨
â”‚   â”‚
â”‚   â””â”€â”€ broadcasters/
â”‚       â”œâ”€â”€ base-broadcaster.ts    # [NEW] æ’­æŠ¥å™¨åŸºç±»
â”‚       â””â”€â”€ persona-broadcaster.ts # [NEW] äººè®¾åŒ–æ’­æŠ¥
â”‚
â”œâ”€â”€ config/tasks/
â”‚   â””â”€â”€ weather.yaml           # [NEW] å¤©æ°”ä»»åŠ¡é…ç½®
â”‚
â””â”€â”€ data/tasks/                # [NEW] ä»»åŠ¡æ•°æ®ç›®å½•
```

### 3.2 ä¿®æ”¹æ–‡ä»¶

```
Source/web/src/
â”œâ”€â”€ hooks/zego/
â”‚   â””â”€â”€ useActionDetector.ts   # [MODIFY] æ·»åŠ ä»»åŠ¡ ACTION å¤„ç†
â”‚
â””â”€â”€ components/call/
    â”œâ”€â”€ CallPage.tsx           # [MODIFY] æ·»åŠ å¤©æ°”å¡ç‰‡æ¸²æŸ“
    â””â”€â”€ WeatherCard.tsx        # [NEW] å¤©æ°”å¡ç‰‡ç»„ä»¶
```

---

## å››ã€æ ¸å¿ƒå®ç°

### 4.1 ç±»å‹å®šä¹‰

```typescript
// lib/tasks/types.ts

export type TaskComplexity = 'low' | 'medium' | 'high';
export type TaskStatus = 'pending' | 'running' | 'completed' | 'failed';

export interface TaskConfig {
  id: string;
  name: string;
  version: string;
  trigger: {
    type: 'keyword';
    keywords: string[];
  };
  complexity: TaskComplexity;
  params?: TaskParam[];
  executor: {
    type: 'builtin';
    handler: string;
  };
  broadcaster: {
    style: 'persona' | 'neutral';
    emotion: string;
  };
  timeout: {
    duration: string;
  };
}

export interface TaskParam {
  name: string;
  source: 'input' | 'memory';
  default_memory_key?: string;
}

export interface TaskSession {
  taskId: string;
  configId: string;
  roomId: string;
  userId: string;
  status: TaskStatus;
  params: Record<string, any>;
  result?: TaskResult;
  error?: string;
  createdAt: number;
}

export interface TaskResult {
  success: boolean;
  data: any;
}

export interface WeatherResult {
  location: string;
  temperature: string;
  weather: string;
  suggestion: string;
  iconCode: string;
}
```

### 4.2 ä»»åŠ¡åŒ¹é…å™¨

```typescript
// lib/tasks/core/task-matcher.ts

import { TaskConfig } from '../types';
import { ConfigLoader } from './config-loader';

export interface MatchResult {
  configId: string;
  config: TaskConfig;
  extractedParams: Record<string, any>;
}

export class TaskMatcher {
  private static instance: TaskMatcher;
  private configLoader: ConfigLoader;
  
  static getInstance(): TaskMatcher {
    if (!this.instance) {
      this.instance = new TaskMatcher();
    }
    return this.instance;
  }
  
  constructor() {
    this.configLoader = ConfigLoader.getInstance();
  }
  
  /**
   * åŒ¹é…ä»»åŠ¡
   * @param input ç”¨æˆ·è¾“å…¥æ–‡æœ¬
   * @returns åŒ¹é…ç»“æœï¼Œæ— åŒ¹é…è¿”å› null
   */
  match(input: string): MatchResult | null {
    const configs = this.configLoader.getAllConfigs();
    
    for (const config of configs) {
      if (this.matchKeywords(input, config.trigger.keywords)) {
        return {
          configId: config.id,
          config,
          extractedParams: this.extractParams(input, config)
        };
      }
    }
    
    return null;
  }
  
  private matchKeywords(input: string, keywords: string[]): boolean {
    const normalized = input.toLowerCase();
    return keywords.some(kw => normalized.includes(kw.toLowerCase()));
  }
  
  private extractParams(input: string, config: TaskConfig): Record<string, any> {
    const params: Record<string, any> = {};
    
    // æå–åœ°ç‚¹ï¼ˆç®€å•å®ç°ï¼Œåç»­å¯ä¼˜åŒ–ï¼‰
    const locationMatch = input.match(/(.{2,4}?)(çš„)?(å¤©æ°”|æ¸©åº¦)/);
    if (locationMatch && locationMatch[1]) {
      params.location = locationMatch[1];
    }
    
    return params;
  }
}
```

### 4.3 ä»»åŠ¡è°ƒåº¦å™¨

```typescript
// lib/tasks/core/task-dispatcher.ts

import { TaskSession, TaskStatus } from '../types';
import { TaskMatcher, MatchResult } from './task-matcher';
import { WeatherExecutor } from '../executors/weather-executor';
import { PersonaBroadcaster } from '../broadcasters/persona-broadcaster';
import { MemoryManager } from '@/lib/memory-manager';
import { sendAgentInstanceLLM } from '@/lib/zego-api';

export class TaskDispatcher {
  private static instance: TaskDispatcher;
  private sessions: Map<string, TaskSession> = new Map();
  
  static getInstance(): TaskDispatcher {
    if (!this.instance) {
      this.instance = new TaskDispatcher();
    }
    return this.instance;
  }
  
  /**
   * åˆ†å‘ä»»åŠ¡
   */
  async dispatch(
    roomId: string,
    userId: string,
    instanceId: string,
    taskType: string,
    inputParams: Record<string, any>
  ): Promise<TaskSession> {
    // 1. è·å–é…ç½®
    const matcher = TaskMatcher.getInstance();
    const config = matcher.getConfigById(taskType);
    
    if (!config) {
      throw new Error(`Unknown task type: ${taskType}`);
    }
    
    // 2. åˆ›å»ºä¼šè¯
    const session = this.createSession(roomId, userId, config.id, inputParams);
    
    // 3. è¡¥å……å‚æ•°ï¼ˆä»ç”¨æˆ·è®°å¿†ï¼‰
    await this.fillParamsFromMemory(session, config, userId);
    
    // 4. æ ¹æ®å¤æ‚åº¦å¤„ç†
    if (config.complexity === 'low') {
      // ä½å¤æ‚åº¦ï¼šç›´æ¥æ‰§è¡Œ
      await this.executeAndBroadcast(session, instanceId);
    }
    // ä¸­/é«˜å¤æ‚åº¦åœ¨åç»­ç‰ˆæœ¬å®ç°
    
    return session;
  }
  
  private createSession(
    roomId: string,
    userId: string,
    configId: string,
    params: Record<string, any>
  ): TaskSession {
    const taskId = `task_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
    
    const session: TaskSession = {
      taskId,
      configId,
      roomId,
      userId,
      status: 'running',
      params,
      createdAt: Date.now()
    };
    
    this.sessions.set(taskId, session);
    return session;
  }
  
  private async fillParamsFromMemory(
    session: TaskSession,
    config: TaskConfig,
    userId: string
  ): Promise<void> {
    // å¦‚æœæ²¡æœ‰åœ°ç‚¹å‚æ•°ï¼Œä»ç”¨æˆ·è®°å¿†è·å–
    if (!session.params.location) {
      const memory = await MemoryManager.getInstance().getUserMemory(userId, 'xiaoye');
      
      if (memory?.targetUser) {
        const match = memory.targetUser.match(/(?:ä½åœ¨|å¸¸é©»|ä½äº|åœ¨)([^\s,ï¼Œã€‚]+)/);
        if (match) {
          session.params.location = match[1];
        }
      }
      
      // é»˜è®¤å€¼
      if (!session.params.location) {
        session.params.location = 'åŒ—äº¬';
      }
    }
  }
  
  private async executeAndBroadcast(
    session: TaskSession,
    instanceId: string
  ): Promise<void> {
    try {
      // æ‰§è¡Œ
      const executor = new WeatherExecutor();
      const result = await executor.execute(session);
      
      session.result = result;
      session.status = 'completed';
      
      // æ’­æŠ¥
      const broadcaster = new PersonaBroadcaster();
      const broadcastText = broadcaster.format(result, session.configId);
      
      // æ³¨å…¥åˆ° LLM
      await sendAgentInstanceLLM(instanceId, session.roomId, broadcastText);
      
    } catch (error) {
      session.status = 'failed';
      session.error = error.message;
      throw error;
    }
  }
}
```

### 4.4 å¤©æ°”æ‰§è¡Œå™¨

```typescript
// lib/tasks/executors/weather-executor.ts

import { BaseExecutor } from './base-executor';
import { TaskSession, TaskResult, WeatherResult } from '../types';
import { BailianClient } from '@/lib/bailian-client';

export class WeatherExecutor extends BaseExecutor {
  readonly id = 'weather';
  
  private bailianClient: BailianClient;
  
  constructor() {
    super();
    this.bailianClient = new BailianClient();
  }
  
  async execute(session: TaskSession): Promise<TaskResult> {
    const location = session.params.location;
    
    // 1. è°ƒç”¨ç™¾ç‚¼è”ç½‘æœç´¢
    const query = `${location}ä»Šå¤©å¤©æ°” æ¸©åº¦ ç©¿è¡£å»ºè®®`;
    const searchResult = await this.bailianClient.search(query);
    
    // 2. è§£æç»“æœ
    const weatherData = await this.parseWeatherResult(searchResult, location);
    
    return {
      success: true,
      data: weatherData
    };
  }
  
  private async parseWeatherResult(
    raw: any,
    location: string
  ): Promise<WeatherResult> {
    // ä½¿ç”¨ LLM è§£ææœç´¢ç»“æœ
    const parsePrompt = `
è¯·ä»ä»¥ä¸‹æœç´¢ç»“æœä¸­æå–å¤©æ°”ä¿¡æ¯ï¼Œè¾“å‡º JSON æ ¼å¼ï¼š

æœç´¢ç»“æœï¼š
${JSON.stringify(raw)}

è¾“å‡ºæ ¼å¼ï¼š
{
  "location": "${location}",
  "temperature": "æœ€ä½-æœ€é«˜Â°C",
  "weather": "å¤©æ°”æè¿°",
  "suggestion": "ç©¿è¡£å»ºè®®",
  "iconCode": "sunny|cloudy|rainy|snowy"
}

åªè¾“å‡º JSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚
`;
    
    const response = await this.bailianClient.chat(parsePrompt);
    return JSON.parse(response);
  }
}
```

### 4.5 äººè®¾åŒ–æ’­æŠ¥å™¨

```typescript
// lib/tasks/broadcasters/persona-broadcaster.ts

import { BaseBroadcaster } from './base-broadcaster';
import { TaskResult, WeatherResult } from '../types';
import { ConfigLoader } from '../core/config-loader';

export class PersonaBroadcaster extends BaseBroadcaster {
  readonly id = 'persona';
  
  format(result: TaskResult, configId: string): string {
    const config = ConfigLoader.getInstance().getConfig(configId);
    
    if (configId === 'weather') {
      return this.formatWeather(result.data as WeatherResult);
    }
    
    return JSON.stringify(result.data);
  }
  
  private formatWeather(data: WeatherResult): string {
    const { location, temperature, weather, suggestion } = data;
    
    // äººè®¾åŒ–æ’­æŠ¥æ¨¡æ¿
    const templates = [
      `${location}ä»Šå¤©${weather}ï¼Œæ°”æ¸©${temperature}ï¼Œ${this.personalizeSuggestion(suggestion)}`,
      `${location}ä»Šå¤©æ˜¯${weather}çš„å¤©æ°”ï¼Œ${temperature}ï¼Œ${this.personalizeSuggestion(suggestion)}`,
    ];
    
    // éšæœºé€‰æ‹©æ¨¡æ¿
    const template = templates[Math.floor(Math.random() * templates.length)];
    return template;
  }
  
  private personalizeSuggestion(suggestion: string): string {
    // æ·»åŠ äººè®¾åŒ–å…³å¿ƒè¯­
    const suffixes = [
      'è®°å¾—ç©¿åšä¸€ç‚¹å“¦ï½',
      'æ³¨æ„ä¿æš–å‘€ï½',
      'å‡ºé—¨è®°å¾—å¸¦ä¼å“¦ï½',
      'ä»Šå¤©é€‚åˆå‡ºå»èµ°èµ°å‘¢ï½'
    ];
    
    if (suggestion.includes('åš') || suggestion.includes('ä¿æš–')) {
      return 'æœ‰ç‚¹å‡‰å“¦ï¼Œ' + suffixes[0];
    } else if (suggestion.includes('ä¼') || suggestion.includes('é›¨')) {
      return suffixes[2];
    } else {
      return suffixes[3];
    }
  }
}
```

### 4.6 é…ç½®åŠ è½½å™¨

```typescript
// lib/tasks/core/config-loader.ts

import fs from 'fs';
import path from 'path';
import yaml from 'yaml';
import { TaskConfig } from '../types';

export class ConfigLoader {
  private static instance: ConfigLoader;
  private configs: Map<string, TaskConfig> = new Map();
  private configDir: string;
  
  static getInstance(): ConfigLoader {
    if (!this.instance) {
      this.instance = new ConfigLoader();
    }
    return this.instance;
  }
  
  constructor() {
    this.configDir = path.join(process.cwd(), 'config/tasks');
    this.loadAllConfigs();
  }
  
  private loadAllConfigs(): void {
    if (!fs.existsSync(this.configDir)) {
      fs.mkdirSync(this.configDir, { recursive: true });
      return;
    }
    
    const files = fs.readdirSync(this.configDir);
    
    for (const file of files) {
      if (file.endsWith('.yaml')) {
        this.loadConfig(path.join(this.configDir, file));
      }
    }
  }
  
  private loadConfig(filepath: string): void {
    try {
      const content = fs.readFileSync(filepath, 'utf-8');
      const data = yaml.parse(content) as { task: TaskConfig };
      
      if (data.task?.id) {
        this.configs.set(data.task.id, data.task);
        console.log(`[ConfigLoader] Loaded: ${data.task.id}`);
      }
    } catch (error) {
      console.error(`[ConfigLoader] Failed to load ${filepath}:`, error);
    }
  }
  
  getConfig(id: string): TaskConfig | undefined {
    return this.configs.get(id);
  }
  
  getAllConfigs(): TaskConfig[] {
    return Array.from(this.configs.values());
  }
}
```

### 4.7 API è·¯ç”±

```typescript
// app/api/task/dispatch/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { TaskDispatcher } from '@/lib/tasks/core/task-dispatcher';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { taskType, params, instanceId, roomId, userId } = body;
    
    // å‚æ•°æ ¡éªŒ
    if (!taskType || !instanceId || !roomId || !userId) {
      return NextResponse.json(
        { error: 'Missing required parameters' },
        { status: 400 }
      );
    }
    
    // åˆ†å‘ä»»åŠ¡
    const dispatcher = TaskDispatcher.getInstance();
    const session = await dispatcher.dispatch(
      roomId,
      userId,
      instanceId,
      taskType,
      params || {}
    );
    
    return NextResponse.json({
      taskId: session.taskId,
      status: session.status,
      result: session.result
    });
    
  } catch (error) {
    console.error('[Task Dispatch Error]', error);
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}
```

---

## äº”ã€ä»»åŠ¡é…ç½®

```yaml
# config/tasks/weather.yaml
task:
  id: weather
  name: å¤©æ°”æŸ¥è¯¢
  version: "1.0"
  
  trigger:
    type: keyword
    keywords:
      - å¤©æ°”
      - æ¸©åº¦
      - ç©¿ä»€ä¹ˆ
      - çƒ­ä¸çƒ­
      - å†·ä¸å†·
      - ä¼šä¸‹é›¨
  
  complexity: low
  
  params:
    - name: location
      source: input
      fallback: memory
      default_memory_key: user_location
  
  executor:
    type: builtin
    handler: weather
  
  broadcaster:
    style: persona
    emotion: happy
  
  timeout:
    duration: 5s
```

---

## å…­ã€å‰ç«¯æ”¹åŠ¨

### 6.1 ACTION æ£€æµ‹æ‰©å±•

```typescript
// hooks/zego/useActionDetector.ts (ä¿®æ”¹)

// æ·»åŠ ä»»åŠ¡ ACTION ç±»å‹
const TASK_ACTIONS = ['TASK:weather'];

// åœ¨ handleAction ä¸­æ·»åŠ 
async function handleAction(action: ParsedAction) {
  if (action.type.startsWith('TASK:')) {
    const taskType = action.type.replace('TASK:', '');
    
    const response = await fetch('/api/task/dispatch', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        taskType,
        params: action.params || {},
        instanceId,
        roomId,
        userId
      })
    });
    
    const result = await response.json();
    
    if (result.status === 'completed' && taskType === 'weather') {
      setWeatherCard(result.result.data);
    }
  }
}
```

### 6.2 å¤©æ°”å¡ç‰‡ç»„ä»¶

```tsx
// components/call/WeatherCard.tsx

import React from 'react';

interface WeatherCardProps {
  data: {
    location: string;
    temperature: string;
    weather: string;
    suggestion: string;
    iconCode: string;
  };
  onClose: () => void;
}

const WEATHER_ICONS: Record<string, string> = {
  sunny: 'â˜€ï¸',
  cloudy: 'â˜ï¸',
  rainy: 'ğŸŒ§ï¸',
  snowy: 'â„ï¸'
};

export function WeatherCard({ data, onClose }: WeatherCardProps) {
  const icon = WEATHER_ICONS[data.iconCode] || 'ğŸŒ¤ï¸';
  
  return (
    <div className="weather-card">
      <div className="weather-header">
        <span className="weather-icon">{icon}</span>
        <span className="weather-location">{data.location}</span>
      </div>
      
      <div className="weather-body">
        <div className="weather-temp">{data.temperature}</div>
        <div className="weather-desc">{data.weather}</div>
      </div>
      
      <div className="weather-footer">
        <span className="weather-suggestion">ğŸ‘” ç©¿è¡£å»ºè®®ï¼š{data.suggestion}</span>
      </div>
      
      <button className="weather-close" onClick={onClose}>âœ•</button>
    </div>
  );
}
```

---

## ä¸ƒã€Prompt æ‰©å±•

### 7.1 ä»»åŠ¡è§¦å‘è§„åˆ™

åœ¨ `core.xml` ä¸­æ·»åŠ ï¼š

```xml
<task_trigger_rules>
  å½“ç”¨æˆ·è¡¨è¾¾ä»¥ä¸‹æ„å›¾æ—¶ï¼Œè¾“å‡ºå¯¹åº” ACTION æ ‡ç­¾ï¼š
  
  | ç”¨æˆ·æ„å›¾ | ACTION |
  |---------|--------|
  | æŸ¥å¤©æ°”/æ¸©åº¦/ç©¿ä»€ä¹ˆ | [ACTION:TASK:weather] |
</task_trigger_rules>
```

---

## å…«ã€å¼€å‘æ­¥éª¤

### 8.1 åç«¯å¼€å‘é¡ºåº

1. **ç±»å‹å®šä¹‰** - `lib/tasks/types.ts`
2. **é…ç½®åŠ è½½** - `lib/tasks/core/config-loader.ts`
3. **å¤©æ°”é…ç½®** - `config/tasks/weather.yaml`
4. **ä»»åŠ¡åŒ¹é…** - `lib/tasks/core/task-matcher.ts`
5. **æ‰§è¡Œå™¨åŸºç±»** - `lib/tasks/executors/base-executor.ts`
6. **å¤©æ°”æ‰§è¡Œå™¨** - `lib/tasks/executors/weather-executor.ts`
7. **æ’­æŠ¥å™¨** - `lib/tasks/broadcasters/persona-broadcaster.ts`
8. **ä»»åŠ¡è°ƒåº¦** - `lib/tasks/core/task-dispatcher.ts`
9. **API è·¯ç”±** - `app/api/task/dispatch/route.ts`

### 8.2 å‰ç«¯å¼€å‘é¡ºåº

1. **å¤©æ°”å¡ç‰‡** - `components/call/WeatherCard.tsx`
2. **ACTION æ‰©å±•** - ä¿®æ”¹ `useActionDetector.ts`
3. **CallPage é›†æˆ** - æ·»åŠ å¡ç‰‡æ¸²æŸ“

### 8.3 Prompt ä¿®æ”¹

1. ä¿®æ”¹ `config/prompts/agents/xiaoye/core.xml`

---

## ä¹ã€éªŒæ”¶æ£€æŸ¥

| æ£€æŸ¥é¡¹ | éªŒæ”¶æ ‡å‡† |
|--------|----------|
| é—²èŠä¸å—å½±å“ | éä»»åŠ¡è¾“å…¥æ— å»¶è¿Ÿå¢åŠ  |
| å¤©æ°”æŸ¥è¯¢ | "ä»Šå¤©å¤©æ°”" 2s å†…è¿”å›ç»“æœ |
| é»˜è®¤åœ°ç‚¹ | ä½¿ç”¨ç”¨æˆ·è®°å¿†å¸¸é©»åœ° |
| æŒ‡å®šåœ°ç‚¹ | "ä¸Šæµ·å¤©æ°”" æ­£ç¡®æŸ¥è¯¢ä¸Šæµ· |
| äººè®¾åŒ–æ’­æŠ¥ | åŒ…å«å…³å¿ƒè¯­ |
| å¡ç‰‡æ˜¾ç¤º | åŒ…å«æ¸©åº¦ã€å¤©æ°”ã€å»ºè®® |
| å¡ç‰‡å…³é—­ | ç”¨æˆ·ç¡®è®¤åå…³é—­ |
